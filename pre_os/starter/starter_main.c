/*******************************************************************************
* Copyright (c) 2015 Intel Corporation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/

#include "mon_defs.h"
#include "msr_defs.h"
#include "ia32_defs.h"
#include "mon_arch_defs.h"
#include "mon_startup.h"
#include "xmon_desc.h"
#include "common.h"
#include "multiboot_util.h"

int run_xmon_loader(xmon_desc_t *td);

extern void __cpuid(int cpu_info[4], int info_type);

static uint64_t __readmsr(uint32_t msr_id)
{
	__asm__ __volatile__ (
		"movl %0, %%ecx\n"
		"xor %%eax, %%eax\n"
		"rdmsr\n"
		:
		: "g" (msr_id)
		: "%ecx", "%eax", "%edx"
		);
}

int check_vmx_support(void)
{
	int info[4];
	uint64_t u;

	/* CPUID: input in eax = 1. */

	__cpuid(info, 1);

	/* CPUID: output in ecx, VT available? */

	if ((info[2] & 0x00000020) == 0) {
		return -1;
	}

	/* Fail if feature is locked and vmx is off. */

	u = __readmsr(IA32_MSR_FEATURE_CONTROL);

	if (((u & 0x01) != 0) && ((u & 0x04) == 0)) {
		return -1;
	}

	return 0;
}

/*
 * must put magic file offset mapping header in .text section
 * because the final binary is generated by "objcopy -j .text ..." to
 * strip all sections but .text
 */
const xmon_loaderbin_file_mapping_header_t file_mapping_hdr_info
__attribute__ ((section(".text#")))
__attribute__ ((aligned(4))) = {
	XMON_LOADERBIN_FILE_MAPPING_HEADER_MAGIC0,      /* magic 0 */
	XMON_LOADERBIN_FILE_MAPPING_HEADER_MAGIC1,      /* magic 1 */
	0,                                              /* clear flags */
	0
};

/* Function: starter_main
 * Description: Called by start() in starter.S. Jumps to xmon_loader - xmon loader.
 *              This function never returns back.
 * Input: Registers pushed right to left:
 *        pushal - eax, ecx, edx, ebx, esp, ebp, esi, edi
 *        pushfl - flags
 */
void starter_main(uint32_t eflags,
		  uint32_t edi,
		  uint32_t esi,
		  uint32_t ebp,
		  uint32_t esp,
		  uint32_t ebx,
		  uint32_t edx,
		  uint32_t ecx,
		  uint32_t eax)
{
	multiboot_info_t *mbi = (multiboot_info_t *)ebx;
	uint32_t magic = eax;
	uint32_t starter_len = ecx;

	mon_guest_cpu_startup_state_t *s;

	/* todo: what if the starter.bin/xmon_pkg.bin wasnot loaded here */
	xmon_memory_layout_t *xmon_mem_layout =
		(xmon_memory_layout_t *)STARTER_DEFAULT_LOAD_ADDR;

	xmon_loader_memory_layout_t *loader_mem;
	xmon_runtime_memory_layout_t *runtime_mem;

	xmon_loaderbin_file_mapping_header_t *file_hdr = NULL, *tmp_hdr;

	xmon_desc_t *xmon_desc;

	/* Supported types of boot methods
	 * 1. multiboot
	 * 2. multiboot2
	 */
	if (magic != MULTIBOOT_BOOTLOADER_MAGIC &&
	    magic != MULTIBOOT2_BOOTLOADER_MAGIC) {
		goto DEADLOOP;
	}

	loader_mem = &(xmon_mem_layout->ldr_mem_base);

	/* search the magic file offset header */
	{
		uint32_t index,
			*tmpbuf,
			*starter_img_base =
			(uint32_t *)(loader_mem->u_ldr_bin.img_base);

		for (tmpbuf = starter_img_base;
		     (uint32_t)tmpbuf <
		     ((uint32_t)starter_img_base + starter_len - 4);
		     tmpbuf++) {
			/* 4 byte aligned searching */
			tmp_hdr = (xmon_loaderbin_file_mapping_header_t *)tmpbuf;

			if ((tmp_hdr->magic0 ==
			     XMON_LOADERBIN_FILE_MAPPING_HEADER_MAGIC0) &&
			    (tmp_hdr->magic1 ==
			     XMON_LOADERBIN_FILE_MAPPING_HEADER_MAGIC1)) {
				file_hdr = tmp_hdr;
				break;
			}
		}

		if (file_hdr == NULL) {
			goto DEADLOOP;
		}
	}

	if (check_vmx_support() != 0) {
		goto DEADLOOP;
	}

	if (magic == MULTIBOOT_BOOTLOADER_MAGIC) {
		/* Check whether the modules are valid */
		if (mbi->flags & MBI_MODULES) {
			multiboot_module_t *mod;
			int i;

			for (i = 0, mod = (multiboot_module_t *)mbi->mods_addr;
			     i < mbi->mods_count;
			     i++, mod++) {
				/* do memory overlap checking */
				if (i == mbi->mods_count - 1) {
					if (mod->mod_end >
					    STARTER_DEFAULT_LOAD_ADDR) {
						goto DEADLOOP;
					}
				}
			}
		}

		/* Bits MBI_AOUT and MBI_ELF are mutually exclusive! */
		if ((mbi->flags & MBI_AOUT) &&
		    (mbi->flags & MBI_ELF)) {
			goto DEADLOOP;
		}


		if (!(mbi->flags & MBI_MEMMAP)) {
			goto DEADLOOP;
		}
	} else if (magic == MULTIBOOT2_BOOTLOADER_MAGIC) {
		/* check whether the modules are valid */
		{
			struct mb2_tag_module *mod =
				(struct mb2_tag_module *)get_mb2_tag_type(
					MB2_TAG_START(
						ebx), MB2_TAG_TYPE_MODULE);
			int i;

			if (mod != NULL) {
				for (i = 0; i < GRUB_MODULE_COUNT; i++) {
					/* do memory overlap checking */
					if (mod->mod_end >
					    STARTER_DEFAULT_LOAD_ADDR) {
						/* ERROR! xmon memory overlaps with module memory */
						goto DEADLOOP;
					}
					mod =
						(struct mb2_tag_module *)
						next_mb2_tag((
								struct mb2_tag *)mod);
					mod =
						(struct mb2_tag_module *)
						get_mb2_tag_type((
								struct mb2_tag *)mod,
							MB2_TAG_TYPE_MODULE);
				}
			}
		}

		if (get_mb2_tag_type(MB2_TAG_START(ebx),
			    MB2_TAG_TYPE_MMAP) == NULL) {
			/* mem map not valid */
			goto DEADLOOP;
		}
	} else {
		goto DEADLOOP;
	}

	xmon_desc = &(loader_mem->u_desc.ed);

	/* clear xmon_desc to ZEROs */
	mon_memset(xmon_desc, 0, sizeof(xmon_desc_t));

	/* assign it to xmon_desc for later reference */
	xmon_desc->loader_mem_addr = (uint32_t)loader_mem;


	/*
	 * caculate the total xmon size < use default value currently >
	 * or get it from cmdline.
	 * TODO: do a runtime xmon size estimation, if it is larger than default
	 *       value XMON_DEFAULT_TOTAL_SIZE, then return an error.
	 * could move to xmon_loader to do so.
	 */
	xmon_desc->xmon.total_size = XMON_DEFAULT_TOTAL_SIZE;

	/* get runtime_mem (xmon_runtime_memory_layout_t) address */
	runtime_mem = &(xmon_mem_layout->rt_mem_base);

	/* assign it to xmon_desc_t for later reference */
	xmon_desc->runtime_mem_addr = (uint32_t)runtime_mem;

	/* note down the multi-boot params from grub bootloader or other bootstubs */
	xmon_desc->mb_initial_state.ebx = ebx;

	/* save module information (file mapped address in RAM + base location )
	 *  TODO: better to caculate what address is starter loaded by bootstub...instead of
	 *        using the hardcode address.
	 */
	if (file_hdr->files[XMON_LOADER_BIN_INDEX].size &&
	    (file_hdr->flags & INDEX_TO_BITMAP_FLAG(XMON_LOADER_BIN_INDEX))) {
		xmon_desc->xmon_loader_file.addr =
			(uint32_t)(loader_mem->u_ldr_bin.img_base) +
			file_hdr->files[
				XMON_LOADER_BIN_INDEX].offset;
		xmon_desc->xmon_loader_file.size =
			file_hdr->files[XMON_LOADER_BIN_INDEX].size;
	} else {
		goto DEADLOOP;
	}

	if (file_hdr->files[STARTAP_BIN_INDEX].size &&
	    (file_hdr->flags & INDEX_TO_BITMAP_FLAG(STARTAP_BIN_INDEX))) {
		xmon_desc->startap_file.addr =
			(uint32_t)(loader_mem->u_ldr_bin.img_base) +
			file_hdr->files[STARTAP_BIN_INDEX].
			offset;
		xmon_desc->startap_file.size =
			file_hdr->files[STARTAP_BIN_INDEX].size;
	} else {
		goto DEADLOOP;
	}

	if (file_hdr->files[XMON_BIN_INDEX].size &&
	    (file_hdr->flags & INDEX_TO_BITMAP_FLAG(XMON_BIN_INDEX))) {
		xmon_desc->xmon_file.addr =
			(uint32_t)(loader_mem->u_ldr_bin.img_base) +
			file_hdr->files[XMON_BIN_INDEX].
			offset;
		xmon_desc->xmon_file.size = file_hdr->files[XMON_BIN_INDEX].size;
	} else {
		goto DEADLOOP;
	}

#define RETURN_ADDRESS() (__builtin_return_address(0))
	/* save multiboot initial state */
	xmon_desc->mb_initial_state.eax = eax;  /* boot magic */
	xmon_desc->mb_initial_state.ebp = ebp;  /* undefined */
	xmon_desc->mb_initial_state.ebx = ebx;  /* boot info */
	xmon_desc->mb_initial_state.ecx = ecx;  /* undefined */
	xmon_desc->mb_initial_state.edi = edi;  /* undefined */
	xmon_desc->mb_initial_state.edx = edx;  /* undefined */
	xmon_desc->mb_initial_state.eflags = eflags;
	xmon_desc->mb_initial_state.eip = (uint32_t)RETURN_ADDRESS(); /* return address of starter_main for now, update when needed*/
	xmon_desc->mb_initial_state.esi = esi;  /* undefined */
	xmon_desc->mb_initial_state.esp = esp;  /* undefined, here uses our own starter stack */

	{
		uint32_t err = run_xmon_loader(xmon_desc);

		if (0 != err) {
			goto DEADLOOP;
		}
	}


DEADLOOP:
	while (1) {
	}
}

/* End of file */
